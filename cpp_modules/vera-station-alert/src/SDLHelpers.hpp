#ifndef __SDL_HELPERS_HPP__
#define __SDL_HELPERS_HPP__

#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>

#include <cmath>
#include <memory>
#include <stdexcept>

#define M_PI 3.14159265358979323846

class SDLException final : public std::runtime_error
{
public:
    explicit SDLException(const std::string &message) : std::runtime_error(message + '\n' + SDL_GetError())
    {
    }
};

struct SDLDeleter
{
    void operator()(SDL_Window *p) const noexcept
    {
        if (p)
        {
            SDL_DestroyWindow(p);
        }
    }

    void operator()(SDL_Renderer *p) const noexcept
    {
        if (p)
        {
            SDL_DestroyRenderer(p);
        }
    }

    void operator()(SDL_Texture *p) const noexcept
    {
        if (p)
        {
            SDL_DestroyTexture(p);
        }
    }

    void operator()(TTF_Font *p) const noexcept
    {
        if (p)
        {
            TTF_CloseFont(p);
        }
    }

    void operator()(TTF_TextEngine *p) const noexcept
    {
        if (p)
        {
            TTF_DestroyRendererTextEngine(p);
        }
    }

    void operator()(TTF_Text *p) const noexcept
    {
        if (p)
        {
            TTF_DestroyText(p);
        }
    }
};

using WindowPtr = std::unique_ptr<SDL_Window, SDLDeleter>;
using RendererPtr = std::unique_ptr<SDL_Renderer, SDLDeleter>;
using TexturePtr = std::unique_ptr<SDL_Texture, SDLDeleter>;
using FontPtr = std::unique_ptr<TTF_Font, SDLDeleter>;
using TextEnginePtr = std::unique_ptr<TTF_TextEngine, SDLDeleter>;
using TextPtr = std::unique_ptr<TTF_Text, SDLDeleter>;

inline void SDLCheck(bool success, const char *context)
{
    if (!success)
    {
        throw SDLException(context);
    }
}

struct SDLInitGuard
{
    SDLInitGuard(SDL_InitFlags flags)
    {
        SDLCheck(SDL_Init(flags), "SDL_Init");
        SDLCheck(TTF_Init(), "TTF_Init");
    }
    ~SDLInitGuard()
    {
        TTF_Quit();
        SDL_Quit();
    }
};

struct Size
{
    int width = 0, height = 0;
};

using RGBAColor = uint32_t;

inline Size GetWindowSize(const WindowPtr &window)
{
    int w, h;
    SDLCheck(SDL_GetWindowSize(window.get(), &w, &h), "SDL_GetWindowSize");
    return Size{w, h};
}

inline void SetRendererSize(const RendererPtr &renderer, const Size &size)
{
    SDLCheck(SDL_SetRenderLogicalPresentation(renderer.get(), size.width, size.height, SDL_LOGICAL_PRESENTATION_DISABLED), "SDL_SetRenderLogicalPresentation");
}

inline Size GetRendererSize(const RendererPtr &renderer)
{
    int w, h;
    SDLCheck(SDL_GetCurrentRenderOutputSize(renderer.get(), &w, &h), "SDL_GetCurrentRenderOutputSize");
    return Size{w, h};
}

inline void PaintFilledCircle(const RendererPtr &renderer, const int centerX, const int centerY, const int r, const RGBAColor color)
{
    const Uint8 *c = (Uint8 *)&color;
    SDL_SetRenderDrawColor(renderer.get(), c[0], c[1], c[2], c[3]);

    // Generated by ChatGPT (and adapted):
    for (int dy = -r; dy <= r; dy++)
    {
        const int dx_limit = (int)std::sqrt(r * r - dy * dy);

        int x1 = centerX - dx_limit;
        int x2 = centerX + dx_limit;
        int y = centerY + dy;

        SDLCheck(SDL_RenderLine(renderer.get(), x1, y, x2, y), "SDL_RenderLine");
    }
}

inline void PaintLine(const RendererPtr &renderer, const float x1, const float y1, const float x2, const float y2, const float thickness, const RGBAColor color)
{
    const Uint8 *c = (Uint8 *)&color;
    const SDL_FColor fColor = {c[0] / 255.0f, c[1] / 255.0f, c[2] / 255.0f, c[3] / 255.0f};

    // Generated by ChatGPT (and adapted):
    // Direction vector
    float dx = x2 - x1;
    float dy = y2 - y1;
    const float length = std::sqrt(dx * dx + dy * dy);
    if (length == 0.0f)
        return;

    // Normalize direction
    dx /= length;
    dy /= length;

    // Perpendicular vector scaled by half the thickness
    const float px = -dy * (thickness / 2.0f);
    const float py = dx * (thickness / 2.0f);

    // Compute the rectangle corners
    SDL_Vertex verts[4];
    verts[0].position = {x1 + px, y1 + py};
    verts[1].position = {x2 + px, y2 + py};
    verts[2].position = {x2 - px, y2 - py};
    verts[3].position = {x1 - px, y1 - py};

    // Set color (you can set this before calling, too)
    for (int i = 0; i < 4; ++i)
    {
        verts[i].color = fColor;
    }

    // Two triangles form the rectangle
    const int indices[6] = {0, 1, 2, 0, 2, 3};
    SDLCheck(SDL_RenderGeometry(renderer.get(), nullptr, verts, 4, indices, 6), "SDL_RenderGeometry");
}

inline TextPtr CreateText(const TextEnginePtr &textEngine, const FontPtr &font, const std::string &text, const RGBAColor color)
{
    const Uint8 *c = (Uint8 *)&color;
    TextPtr t{TTF_CreateText(textEngine.get(), font.get(), text.c_str(), 0), SDLDeleter{}};
    SDLCheck(t != nullptr, "TTF_CreateText");
    SDLCheck(TTF_SetTextColor(t.get(), c[0], c[1], c[2], c[3]), "TTF_SetTextColor");
    return t;
}

inline void PaintText(const TextPtr &text, const float x, const float y)
{
    SDLCheck(TTF_DrawRendererText(text.get(), x, y), "TTF_DrawRendererText");
}

inline void PaintText(const TextEnginePtr &textEngine, const FontPtr &font, const std::string &text, const float x, const float y, const RGBAColor color)
{
    PaintText(CreateText(textEngine, font, text, color), x, y);
}

inline Size GetTextSize(const TextPtr &text)
{
    int w, h;
    SDLCheck(TTF_GetTextSize(text.get(), &w, &h), "TTF_GetTextSize");
    return Size{w, h};
}

inline void RenderTexture(const RendererPtr &renderer, const TexturePtr &texture)
{
    SDLCheck(SDL_RenderTexture(renderer.get(), texture.get(), nullptr, nullptr), "SDL_RenderTexture");
}

inline void PaintFilledRect(const RendererPtr &renderer, const float x, const float y, const float w, const float h, const RGBAColor color)
{
    const Uint8 *c = (Uint8 *)&color;
    SDL_SetRenderDrawColor(renderer.get(), c[0], c[1], c[2], c[3]);
    const SDL_FRect rect{x, y, w, h};
    SDLCheck(SDL_RenderFillRect(renderer.get(), &rect), "SDL_RenderFillRect");
}

inline void ClearBackground(const RendererPtr &renderer, const RGBAColor color)
{
    const Uint8 *c = (Uint8 *)&color;
    SDL_SetRenderDrawColor(renderer.get(), c[0], c[1], c[2], c[3]);
    SDL_RenderClear(renderer.get());
}

inline RGBAColor RGBA(Uint8 r, Uint8 g, Uint8 b, Uint8 a = 255)
{
#if SDL_BYTEORDER == SDL_BIG_ENDIAN
    return (r << 24) | (g << 16) | (b << 8) | a;
#else
    return (a << 24) | (b << 16) | (g << 8) | r;
#endif
}

#endif